# 我们给定一个n×n的矩阵，矩阵中的每个元素是 0 或 1。你需要计算在这个矩阵中，有多少个“完美矩形区域”，这里的完美矩形区域的定义是：一个矩形区域内，0的数量等于1的数量。n×n

# 我们的目标是：
# 对每种大小的矩形区域（例如 1×1, 2×2, 3×3, ...n×n），找出矩阵中有多少个这样的完美矩形区域。
# 输出每个矩形大小的结果。

# 分析步骤
# 矩阵内容：矩阵是一个 的二值矩阵。矩阵中的元素要么是 0，要么是 1。n×n
# 完美矩形：一个矩形区域是完美的，当且仅当它内含的 0 的数量等于 1 的数量。

# 任务：对于每个可能的矩形大小（从 1×1 到 n×n），我们需要遍历矩阵，检查每个可能的矩形区域，判断其中 0 和 1 的数量是否相等。

# 解决思路
# 由于暴力方法会花费太多时间，我们先采用一种简单的方式，逐个检查每个矩形区域的 0 和 1 数量。

# 步骤
# 逐个检查每个矩形：我们可以用一个双重循环来遍历矩阵中的所有可能的矩形区域。
# 计算矩形内的0和1的数量：对于每个矩形区域，统计其中0的数量，和1的数量。如果相等，则认为它是一个完美矩形。

# 优化：通过这种方式，直接对每个矩形进行检查，虽然可以解决问题，但我们要注意这个方法的效率问题。我们先从这个简单的方法开始，之后再进行优化。

# 读取输入
n = int(input("请输入："))  # 矩阵大小
matrix = [input().strip() for _ in range(n)]  # 读取n行的矩阵

# 用来存储每个大小矩形的完美矩形数量
result = [0] * (n + 1)

# 遍历每种大小的矩形
for size in range(1, n + 1):  # size 是矩形的边长
    count = 0  # 当前矩形大小的完美矩形计数
    # 遍历矩阵中的所有起始位置，检查每个size * size的矩形
    for i in range(n - size + 1):
        for j in range(n - size + 1):
            # 计算矩形区域的 0 和 1 数量
            num_0 = 0
            num_1 = 0
            # 检查当前矩形区域
            for x in range(size):
                for y in range(size):
                    if matrix[i + x][j + y] == '0':
                        num_0 += 1
                    else:
                        num_1 += 1
            # 如果0的数量等于1的数量，那么就是一个完美矩形
            if num_0 == num_1:
                count += 1
    # 存储当前矩形大小的完美矩形数量
    result[size] = count

# 输出每个矩形大小的完美矩形数量
for res in result[1:]:
    print(res)
